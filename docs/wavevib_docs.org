#+TITLE:WaveVib - An OCTAVE/MATLAB Toolbox for Wave-Based Modeling of Nonlinear Jointed Structures
#+EXPORT_FILE_NAME: index.html
#+OPTIONS: startup:indent
#+BIBLIOGRAPHY: wavevib_docs.bib
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD: <style> #content{max-width:1800px;}</style>

* Introduction
WaveVib is intended to be a set of OCTAVE/MATLAB routines that can be used to study wave-based linear and nonlinear structures. The main advantage with using this approach comes from the fact that the linear portions of the problem are represented without any approximation (unlike weighted residual or variational approaches). The interface supports both periodic as well as quasi-periodic steady state response regimes. Immediate use cases include jointed beams, trusses, frame structures, fluid-filled columns, rotordynamics, etc.

A good starting place for the new user to the Wave-Based Modeling (WBM) framework &/or this package are the papers [cite:@balajiWavebasedAnalysisJointed2022;@balajiWavebasedAnalysisJointed2023], upon which most of the rudiments of this package are based.
** The different folders in the repository
1. [[file:../ROUTINES/][ROUTINES]]
   Contains the core routines of the package.
2. [[file:../EXAMPLES/][EXAMPLES]]
   Contains examples with most of the core functionality
3. [[file:../REPS/][REPS]]
   Contains miscellaneous reports (under REPn folders)
4. [[file:wavevib_docs.org][docs]]
   Contains this main documentation
5. [[file:../DEVEL_QPER/][DEVEL\under{}QPER]]
   Contains development scripts used for development of the quasi-periodic response routines & examples. 
6. [[file:../DEVEL_PER/][DEVEL\under{}PER]] [Obsolete]
   Contains development scripts used for development of the periodic response routines & examples.
* COMMENT Programming Interface
Coming soon...
* [[file:../EXAMPLES/][Examples]]
** COMMENT [[file:../EXAMPLES/a_singlebar.m][Single Bar]]
Coming soon...
** COMMENT [[file:../EXAMPLES/b_linjointedbars.m][Linear-Jointed Bars]]
Coming soon...
** COMMENT [[file:../EXAMPLES/c_nljointedbars.m][Nonlinear-Jointed Bars]]
Coming soon...
** COMMENT [[file:../EXAMPLES/d_nljointedEBbeams.m][Nonlinear-Jointed Euler-Bernoulli Beams]]
Coming soon...
** [[file:../EXAMPLES/e_nlimpactclbeams.m][Impacting Cantilever Beams]]    
This is an example from [cite:@praveenkrishnaExperimentalNumericalInvestigations2012], where the dynamics of an impacting cantilever beam setup is investigated. The technical interest in this example is motivated from the broader are of vibro-impact dynamics[cite:@emaciNumericalExperimentalStudy1997], wherein the advantages of the wave based approach are expected to be particularly relevant (due to the avoidance of spatial discretization).

A schematic of the setup is shown below in fig. [[fig:iclbeamsetup]] and the material properties used for this example are presented in tab. [[tab:matprops]].
#+CAPTION: Schematic of the impacting cantilever beam setup [cite:@praveenkrishnaExperimentalNumericalInvestigations2012]
#+NAME: fig:iclbeamsetup
[[./FIGS/iclbeamsetup.png]]
#+CAPTION: Material Properties assumed for the example in [[file:../EXAMPLES/e_nlimpactclbeams.m]]
#+NAME: tab:matprops
| Young's Modulus (GPa) | Density (kg/m^3) | Section (mm^2) | Lengths (mm) | Excitation Point (mm) | Rayleigh damping (\alpha, \beta) | Contact Gap (mm) | Contact Stiffness (N/m) |
|-----------------------+------------------+----------------+--------------+-----------------------+----------------------------------+------------------+-------------------------|
|                   210 |             7680 | 3 \times 40    | 560, 445     | 560/6                 | (0.80, 1.1\times 10^{-4})        |              2.5 |                     110 |

*** Code Overview
The most important part of the code are from line 16 to line 107. The complete code is explained below in different blocks.
#+begin_Details "Declare Properties"
Here we just assign variables to the properties that will be useful for declaring properties.
#+NAME: cd:decl
#+begin_src octave -n
  addpath('../ROUTINES/SOLVERS/')
  addpath('../ROUTINES/WBM/')

  %% Setup Model
  Ey = 2.1e11;
  rho = 7680;
  thk = 3e-3;   % Thickness 1
  wid  = 40e-3;  % Width
  Ar = thk*wid;  % Area
  Iy = thk^3*wid/12;  % 2nd moment of area
  L1  = 560e-3;  % Primary beam length
  xF1 = L1/6;    % Excitation Location (on primary beam)
  L2 = 445e-3;  % Secondary beam length (each)
  al = 0.80;    % 0.80, 1.80
  bt = 1.1e-4;  % 1.1e-4, 2.475e-4
  % Joint parameters
  knl = 220/2;      % 220,      880,    (242, 484, 880, 1210)
  gap = 2.5e-3;   % 2.5e-3,   0.35,   0.35
#+end_src
#+end_Details
#+begin_Details "Declare Dispersion Relationship" :background-color white
Here we declare the dispersion relationship that will be used in the model
#+NAME: cd:disps
#+begin_src octave +n
  % Declare a library of dispersion relationships (only one here) 
  Klib = struct('K', @(w,xi) ((rho*Ar*(w.^2+1j*w*al))./(Ey*Iy*(1-1j*w*bt))).^(0.25) ); 
  wcomps = [1 1;  % First component -> exp(  k x )
	   -1 1;  % Second component-> exp( -k x )
				   1j 1;  % Third component -> exp( ik x )
				  -1j 1]; % Fourth component-> exp(-ik x )

  % If multiple dispersion relationships are present in a model, Klib
  % must be declared as a vector of structs, and the second column of
  % wcomps must be used to refer to an appropriate entry in this.
#+end_src
The format is that the 'K' is a function of frequency 'w' and some parameter (could be vector) 'xi'. The array wcomps declares how to use the dispersion relationships from the 'Klib' library structure.

Here is an example of how to declare multiple dispersion relationships:
#+NAME: cd:mulKs
#+begin_src octave
  Klib = [struct('K', @(w,xi) sqrt((-b.v(w,xi)+sqrt(b.v(w,xi).^2-4*a*c.v(w,xi)))/(2*a))); ...
      struct('K', @(w,xi) sqrt((-b.v(w,xi)-sqrt(b.v(w,xi).^2-4*a*c.v(w,xi)))/(2*a)))];
  wcomps = [1j 1;  % +jK1
	   -1j 1;  % -jK1
	    1j 2;  % +jK2
	   -1j 2]; % -jK2
#+end_src
#+end_Details
#+begin_Details "Setup the model, boundary conditions, and excitation"
+ Firstly, the difference "pieces" of the model are specified:
  #+NAME: cd:pcs
  #+begin_src octave +n
    % Setup "wave-based pieces"
    pcs = [struct('coords', [0 0;xF1 0;L1 0], 'wcomps', wcomps);
			     struct('coords', [L1 gap;L1+L2 gap], 'wcomps', wcomps);
			     struct('coords', [L1 -gap;L1+L2 -gap], 'wcomps', wcomps)];
  #+end_src
  In this model there are three pieces: one for each beam. The first beam is declared with three coordinate points (each row is a separate point). The second point is introduced at the excitation location. Note here that each piece is also associated with its own wave components (declared above in snippet [[cd:disps]]).
+ Next, the boundary conditions are specified:
  #+NAME: cd: bcs
  #+begin_src octave +n
    %% Setup boundary conditions
    bcs = [struct('i', 1, 'cofs', @(w,xi) [1 1 1 1; 1 -1 1j -1j]);  % fixed end
			     struct('i', 5, 'cofs', @(w,xi) [1 1 1 1; 1 -1 1j -1j]);     % fixed end
			     struct('i', 7, 'cofs', @(w,xi) [1 1 1 1; 1 -1 1j -1j]);     % fixed end
			     struct('i', 3, 'cofs', @(w,xi) [1 1 -1 -1]);        % Moment-free
			     struct('i', 4, 'cofs', @(w,xi) [1 1 -1 -1]);        % Moment-free
			     struct('i', 6, 'cofs', @(w,xi) [1 1 -1 -1])];       % Moment-free
  #+end_src
  The parameter 'i' specifies the point in the pieces structure where the boundary condition is specified. The indexing is global, i.e., the points are counted in the order provided; piece 1 has points 1-3, piece 2 has points 4-5, and piece 3 has points 6-7.
+ Now the excitation is specified:
  #+begin_src octave +n
    %% Setup excitation (unit magnitude assumed)
    Mx = @(w,xi) inv([Ey*Iy*Klib.K(w,xi)^3*[-1 1 1j -1j];
		      Ey*Iy*Klib.K(w,xi)^2*[-1 -1 1 1];
		      [1 1 1 1];
		      Klib.K(w,xi)*[1 -1 1j -1j]]);

    excs = struct('i', 2, 'nh', 1, ...
	'rcofs', @(w,xi) Mx(w,xi)*[1/2;0;0;0]);
    %'nh' sets the harmonic at which to apply the excitation
  #+end_src
#+end_Details
#+begin_Details "Setup the Nonlinear Joint after Specifying AFT" :background-color white
+ We now specify the non-linear joint. This is done by first specifying the AFT (Alternating Frequency-Time) parameters:
  #+begin_src octave +n
    %% Setup AFT Parameters
    h = (1:5)';  % List of harmonics to balance
    Nt = 2^10;   % Number of time samples for AFT
  #+end_src
+ The beam interactions are modeled as a three-way joint connecting the three beams. Denoting the relevant tip displacement of the primary beam as beam $u_1$, and the two secondary beams as $u_{2a}$ and $u_{2b}$ respectfully, the force balance equations are,
  #+NAME: eq:fbal
  \begin{align}
    -E_y I_y \frac{\partial^3 u_{2a}}{\partial x^3} &= f_{joint} (u_{2a}-u_1)\\
    -E_y I_y \frac{\partial^3 u_{2b}}{\partial x^3} &= f_{joint} (u_{2b}-u_1)\\
    -E_y I_y \frac{\partial^3 u_1}{\partial x^3} &= -E_y I_y \left(\frac{\partial^3 u_{2a}}{\partial x^3} + \frac{\partial^3 u_{2b}}{\partial x^3} \right)
  \end{align}
  This is setup in the wave-based context as
  #+begin_src octave +n
    %% Setup the joint
    cofs = @(w,xi) [-[zeros(1,4) 1 -1 -1j 1j zeros(1,4)];
	-[zeros(1,8) 1 -1 -1j 1j];
	kron([1 -1 -1], [1 -1 -1j 1j])];
    joints = struct('type', 3, 'is', [3 4 6], ...
	'cofs', cofs, 'nl', @(Uw) HCONTACT(Uw, knl, gap, h, Nt), ...
	'nldcofs', @(w,xi) kron([1 -1 0;1 0 -1], [1 1 1 1]), ...
	'nlfcofs', @(w,xi) [eye(2);0 0]/(Ey*Iy*Klib.K(w,xi)^3));
  #+end_src
  *NOTE*: The 'nldcofs' specifies the coefficient matrix such that the displacement(s) used as input for the nonlinearity is given as,
  | u = NLDCOFS * [a;b] |
  where "a" and "b" are the wave coefficients of points 'i' and 'j' respectively.
  
  The 'nlfcofs' specifies the coefficient matrix that the results from the nonlinear force function are multiplied with before being added to the equations of motion. The nonlinear forces are added in the LHS of the equations.

  #+begin_details "The nonlinearity function HCONTACT"
  This function conducts AFT and evaluates the linear-penalty contact model and returns the harmonics of the force for a given set of displacement harmonics.
  The function is implemented in [[file:../EXAMPLES/HCONTACT.m][HCONTACT.m]].
  #+begin_src octave
    function [FNL, dFNLdU, dFNLdw] = HCONTACT(Uw, knl, gap, h, Nt)
    %HCONTACT returns the Fourier Coefficients of the contact model implemented
    %as a linear-penalty model. Force that is returned is:
    %                   knl*max(u-gap, 0)
    %   positive (u-gap) quantity is considered as contact and negative is
    %   considered as separation (zero force). 
    %
    %   USAGE: 
    %       [FNL, dFNLdU, dFNLdw] = HCONTACT(Uw, knl, gap, h, Nt);
    %   INPUTS:
    %       Uw      : (Nhc*Nd+1,1) Vector of nonlinear relative DOFs+freq.
    %       knl,gap : (scalar) or (Nd,1) parameters
    %       h       : (Nh,1) Vector of Harmonics
    %       Nt      : (int) Number of samples for AFT
    %   OUTPUTS:
    %       FNL     : (Nhc*Nd,1) Force harmonics
    %       dFNLdU  : (Nhc*Nd,Nhc*Nd) Force harmonic jacobian wrt U
    %       dFNLdw  : (Nhc*Nd,1) Force harmonic jacobian wrt w

      Nhc = sum((h==0)+2*(h~=0));
      cst = AFT(eye(Nhc), h, Nt, 'f2t');

      Nd = (size(Uw,1)-1)/Nhc;  % Number of harmonics
      if length(knl)==1
		    knl = ones(1,Nd)*knl;
      end
      if length(gap)==1
		    gap = ones(1,Nd)*gap;
      end

      % Evaluate nonlinear force through AFT
      ut = AFT(reshape(Uw(1:end-1), Nd, Nhc)', h, Nt, 'f2t');
      ft = knl.*max(ut-gap, 0);
      dfdu = knl.*(ft~=0);

      FNL    = reshape(AFT(ft, h, Nt, 't2f')', Nd*Nhc,1);
      dFNLdU = zeros(Nd*Nhc);
      for di=1:Nd
		    dFNLdU(di:Nd:end,di:Nd:end) = AFT(dfdu(:,di).*cst, h, Nt, 't2f');
      end
      dFNLdw = zeros(Nhc*Nd,1);
    end
  #+end_src
#+end_details
#+end_Details

#+begin_Details "Preprocess the model"
After the above setup is done, it is necessary to preprocess the model. Some of the main things wavevib does at this juncture is the inclusion of repeated points (excitation point has to be repeated, for example), and then calculating the frequency (and parameter) derivatives of the provided dispersion and coefficient functions. These derivatives are computed in =WaveVib= through Matlab's =symbolic toolbox= and then stored as anonymous functions. This might make the =WBPREPROC= function slightly slow to call, but during execution of the linear or nonlinear analyses, no symbolics is used and will thus be quite fast. This is because symbolics are used to compute the expressions only, but are not saved - these expressions are converted to regular matlab expressions before saving them.
#+begin_src octave +n
  %% Pre-Processing
  [pcs, bcs, joints, excs, Klib] = WBPREPROC(pcs, bcs, joints, excs, Klib);
#+end_src
The user may check all the objects again now - they will contain additional information in a format that is easy for =WaveVib= to employ. Please do not call =WBPREPROC= again on the returned parameters as this will result in duplicated points, etc.
#+end_Details

#+begin_Details "Conduct Nonlinear Forced Response Analysis using Continuation" :background-color white
+ First the necessary parameters for the continuation are setup:
  #+begin_src octave +n
    %% Setup continuation parameters
    Npts = pcs(end).irange(end);  % Number of points in model
    Nwc = size(wcomps,1);         % Number of wave coefficients per point (4, here)

    Nh = length(h);  					    % Number of harmonics to balance
    Nhc = sum((h==0)+2*(h~=0));   % Number of real harmonic coefficients
				  % zero harmonic-1 ; other harmonics-sine & cosine
    % Generate indices for easy conversion between complex and real representation
    [zinds,hinds,rinds0,rinds,iinds] = HINDS(Npts*Nwc, h);

    Wst = 2*pi*4;   % Starting frequency for continuation
    Wen = 2*pi*12;  % Ending frequency for continuation
    dw = 0.75;      % Continuation step length 

    Famps = [0.4 1.0 2.5];  % List of forcing values to conduct analysis

    % Continuation Properties
    Copt = struct('Nmax', 600, 'angopt', 5e-2, 'DynDscale', 1, ...
		  'Dscale', [1e-6*ones(size(ari0));Wst]);
    % Nmax: Maximum number of points
    % angopt: optimal angle between points (for steplength adaption)
    % DynDscale: Dynamic "Dscaling".
    % Dscale: Initial Dscale vector (Dscale scales the vector of unknowns)

    acC = cell(size(Famps));  % Cell to store solution points
  #+end_src
+ Next a loop is run to conduct the actual continuation
  #+begin_src octave +n
    %% Conduct continuation for the different forcing amplitudes
    for fi=1:length(Famps)
	    % Generate linear initial guess for first point
      [Amat, ~, ~, Fv] = WVAMAT([Wst;0], h, pcs, bcs, joints, Klib, 'r');
      ari0 = Amat\(Fv*Famps(fi));

	    % Run the continuation routine "CONTINUE" by calling the HB residue
	    % function (which actually implements PWE) at the 
      ariwC = CONTINUE(@(ariw) WVHBRESFUN(ariw, Famps(fi), h, pcs, bcs, ...
					  joints, Klib), ari0, Wst, Wen, ...
		       dw, Copt);  

      % Convert to complex representation
      acC{fi} = zeros(Npts*Nwc*Nh+1, size(ariwC,2)); 
      acC{fi}([zinds hinds end], :) = ...
		    [ariwC(rinds0,:); ariwC(rinds,:)+1j*ariwC(iinds,:);ariwC(end,:)];
    end

  #+end_src
#+end_Details

#+begin_Details "Postprocessing"
The =WVEVALWCOFS= routine is provided to help with postprocessing the results. The function uses the complex wave coefficients =ac= and evaluates the solution at =Nx= points in each piece of the model. 
#+begin_details "The =WVEVAlWCOFS= function" :background-color white
#+begin_src octave
  function [Us, Xs] = WVEVALWCOFS(ac, w, h, dL, Nx, pcs, Klib)
  %WVEVALWCOFS This is a routine for evaluating the wave coefficients at
  %arbitrary points on the model. 
  %
  %   USAGE:
  %       [Us, Xs] = WVEVALWCOFS(ac, w, h, dL, Nx, pcs, Klib);
  %   INPUTS:
  %       ac       : (Npts*Nwc, Nh) vector of complex wave coefficients
  %       w        : (1,1) frequency
  %       h        : (Nh,1) list of harmonics
  %       dL       : (1,Nwc) component summing vector
  %       Nx       : (1,1) Number of points per piece
  %       pcs      : Pieces structure
  %       Klib     : K library structure
  %   OUTPUTS:
  %       Us       : (Npcs, 1) cell, each with (Nx, Nh) wave coefficients
  %       Xs       : (Npcs, 1) cell, each with (Nx, 3) coordinate points    

      Nh = length(h);

      Xs = arrayfun(@(pc) cell2mat(arrayfun(@(i) linspace(pc.coords(1,i), pc.coords(end,i), Nx)', 1:3, 'UniformOutput', false)), pcs, 'UniformOutput', false);
      Us = arrayfun(@(pc) zeros(Nx,Nh), pcs, 'UniformOutput', false);

      for hi=1:Nh
	  for n=1:length(pcs)
	      Ks = pcs(n).wcomps(:,1).*cellfun(@(c) c(h(hi)*w,0), {Klib(pcs(n).wcomps(:,2)).K}.');

	      x1 = (Xs{n}-pcs(n).coords(1,:))*pcs(n).V/pcs(n).S;  % Ordered 1D version of pts
	      for i=1:pcs(n).N-1
		  inds = find(pcs(n).U(i)-x1<=eps & x1-pcs(n).U(i+1)<=eps);

		  k = pcs(n).irange(1)-1+i;
		  Us{n}(inds,hi) = dL*(ac((k-1)*4+(1:4),hi).*exp(Ks.*((x1(inds)-pcs(n).U(i))*pcs(n).S)'));
	      end
	  end
      end
  end
#+end_src
#+end_details

The deflection shapes of the harmonic corresponding to column =hi= of the output =Us= can be plotted by
#+begin_src octave
  for n=1:length(pcs)
    plot(Xs{n}(:,1), Xs{n}(:,2), 'k-'); hold on  % Undeformed

    plot(Xs{n}(:,1), Xs{n}(:,2)+real(Us{n}(:,hi)), '.-', 'Color', colos(n,:));  % real part
    plot(Xs{n}(:,1), Xs{n}(:,2)+imag(Us{n}(:,hi)), '.--', 'Color', colos(n,:)); % imag part

    % Also plot the deformations at the model points
    achi = ac(:, hi);
    Up = sum(achi(((pcs(n).irange(1):pcs(n).irange(2))'-1)*4+(1:4)), 2)*exp(-1j*angle(uall(mi)));
    plot(pcs(n).coords(:,1), pcs(n).coords(:,2)+imag(Up), 'ro', 'MarkerFaceColor', 'w')
    plot(pcs(n).coords(:,1), pcs(n).coords(:,2)+real(Up), 'ko', 'MarkerFaceColor', 'r')
  end
#+end_src
#+end_Details
*** Results
    Fig. [[fig:e_out]] plots the forced response results of this system (first harmonic) computed at three difference excitation amplitude levels. The expected behavior  corresponding to impact (linear until the gap is reached, followed by stiffening behavior) is observed. The tip displacement of the primary beam is plotted in the figures.
    #+NAME: fig:e_out
    #+CAPTION: Forced Response Results for the Impacting Cantilever Beam Example
    #+ATTR_HTML: :width 600px
    [[./FIGS/E_out.png]]

    Fig. [[fig:e_outshape]] below plots the same along with the deflection shape corresponding to the first harmonic. A slider is implemented in [[file:../EXAMPLES/e_nlimpactclbeams.m][the matlab script]] that allows one to observe the deflection shape at different points along the forced response. So it is recommended to try running the code and moving the slider around a little bit. 
    #+NAME: fig:e_outshape
    #+CAPTION: Forced Response along with deflection shapes
    #+ATTR_HTML: :width 600px
    [[./FIGS/E_outshape.png]]
    
    *Note*: All the code in [[file:../EXAMPLES/e_nlimpactclbeams.m][the matlab script]] from line 107 onwards are merely postprocessing, and the user may choose to do this their own way also.
* Desirable Features [2/6]
1. [ ] 3D frame joint constitutions
2. [ ] EPMC Implementation
3. [X] Joints connecting multiple pieces
4. [ ] More detailed examples
5. [ ] Stability Implementation
6. [X] Quasi-Periodic Calculations
* References
#+CITE_EXPORT: csl ieee.csl
#+PRINT_BIBLIOGRAPHY: References


#+BEGIN_EXPORT html
<!-- <script type="text/javascript" src="./collcont_clkbls.js"></script> -->
#+END_EXPORT
